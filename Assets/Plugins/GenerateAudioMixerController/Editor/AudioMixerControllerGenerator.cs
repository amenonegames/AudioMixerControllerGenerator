using UnityEngine;
using UnityEditor;
using System.IO;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;


namespace Amenonegames.GenerageAudioMixerController.Editor
{
    public class AudioMixerControllerGenerator
    {
        private AudioMixerControllerGenerationSetting settings;
        private string enumName = "ExposedProperty";

        private string[] _properties;
        private string changeMethodSwitchable;
        private string resetMethodSwitchable;
        private string changeMethodAsyncSwitchable;
        private string resetMethodAsyncSwitchable;

        public AudioMixerControllerGenerator(string[] properties,bool requireAsyncMethod, bool requireInterfaceGeneration)
        {
            _properties = properties;
            settings = new AudioMixerControllerGenerationSetting(requireAsyncMethod, requireInterfaceGeneration);
        }

        public void Generate()
        {
            GenerateClassAndInterface();
        }
        
        private void GenerateClassAndInterface()
        {
            string thisClassName = "";
            var declaringType = MethodBase.GetCurrentMethod()?.DeclaringType;
            if (declaringType != null)
            {
                thisClassName = declaringType?.Name;
            }

            var classFilePath = settings.GenerateClassFilePath();
            
            // Create Directory if not exists
            string directoryPath = "";
            directoryPath = Path.GetDirectoryName(classFilePath);
            if (!Directory.Exists(directoryPath))
                if (directoryPath != null)
                    Directory.CreateDirectory(directoryPath);
            
            // if override files is not required, generate unique path.
            // if file is already exists, add number to the end of the file name.
            string classFilePathInMethod = classFilePath;
            if(!settings.requireOverrideFiles)
                classFilePathInMethod = AssetDatabase.GenerateUniqueAssetPath(classFilePath);
            
            var classCode = GenerateClassString(settings.className, settings.interfaceName, thisClassName);
            File.WriteAllText(classFilePathInMethod, classCode);
            AssetDatabase.ImportAsset(classFilePathInMethod);
            
            if (settings.requireInterfaceGeneration)
            {
                var interfaceFilePath = settings.GenerateInterfaceFilePath();
                directoryPath = Path.GetDirectoryName(interfaceFilePath);
                // Create Directory if not exists
                if (!Directory.Exists(directoryPath))
                    if (directoryPath != null)
                        Directory.CreateDirectory(directoryPath);
                
                // if override files is not required, generate unique path.
                // if file is already exists, add number to the end of the file name.
                string interfaceFilePathInMethod = interfaceFilePath;
                if(!settings.requireOverrideFiles)
                    interfaceFilePathInMethod = AssetDatabase.GenerateUniqueAssetPath(interfaceFilePath);
                
                var interfaceCode = GenerateInterfaceString(settings.interfaceName, thisClassName);
                File.WriteAllText(interfaceFilePathInMethod, interfaceCode);
                AssetDatabase.ImportAsset(interfaceFilePathInMethod);
            }
            
            // refresh UnityEditor
            AssetDatabase.Refresh();
        }

        private string GenerateClassString(string className, string interfaceName, string thisClassName)
        {
            StringBuilder code = new();
            string classImportNameSpace = settings.GenerateClassImportNameSpace();

            code.Append(
                @$"
{classImportNameSpace}");

            if(!string.IsNullOrEmpty(settings.classNameSpace))
            {
                code.Append(@$"
namespace {settings.classNameSpace}
{{
");
            }
            
            code.Append(
                @$"
        /// <summary>
        /// This class is generated by script : {thisClassName}
        /// </summary>
        public class {className}");
            
            if(settings.isMonoBehaviourAndSerializeAudioMixer && settings.requireInterfaceGeneration)
                code.Append($":MonoBehaviour , {interfaceName}");
            else if(settings.isMonoBehaviourAndSerializeAudioMixer)
                code.Append($":MonoBehaviour");
            else if(settings.requireInterfaceGeneration)
                code.Append($":{interfaceName}");

            code.Append(
                @$"
        {{");

            if (settings.isMonoBehaviourAndSerializeAudioMixer)
            {
                code.Append(
                    @$"
            [SerializeField]private AudioMixer _audioMixer;
"
                );
                
            }
            else
            {
                code.Append(
                    @$"
            private readonly AudioMixer _audioMixer;
"
                );
            }

            foreach (var property in _properties)
            {
                code.Append
                (
                    @$"
            private float _original{property};
"
                );
            }

            code.Append
            (
                @$"
            {settings.additionalClasVariableDeclaration}
");

            // if isMonoBehaviourAndSerializeAudioMixer is true, generate Awake method.
            // if isMonoBehaviourAndSerializeAudioMixer is false, generate Constructor.
            if (!settings.isMonoBehaviourAndSerializeAudioMixer)
            {
                code.Append
                (
                    @$"
            public {className}(AudioMixer audioMixer)
            {{
                _audioMixer = audioMixer;
"
                );
                foreach (var property in _properties)
                {
                    code.Append
                    (@$"
                _audioMixer.GetFloat(""{property}"", out _original{property});
"
                    );
                }
            }
            else
            {
                code.Append
                (
                    @$"
            private void Awake()
            {{
"
                );
                
                foreach (var property in _properties)
                {
                    code.Append
                    (@$"
                _audioMixer.GetFloat(""{property}"", out _original{property});
"
                    );
                }
            }
            
            code.Append(@"

            }"
            );
            
            changeMethodSwitchable = settings.GenerateChangeMethodName("ExposedProperty");
            // remove last bracket
            string pattern = @"\)[^\)]*$";
            changeMethodSwitchable = Regex.Replace(changeMethodSwitchable, pattern, "");
            changeMethodSwitchable += " ,"+ enumName + " prop)";
            code.Append(@$"
            public {changeMethodSwitchable}
            {{
                switch(prop)
                {{"
            );
            
            foreach (var property in _properties)
            {
                var changeMethodCall = settings.GenerateChangeMethodCall(property);
                code.Append(@$"
                    case {enumName}.{property}:
                        {changeMethodCall};
                        break;"
                );
            }
            
            code.Append(@"
                }
            }");
            
            resetMethodSwitchable = settings.GenerateResetMethodName("ExposedProperty");
            // remove last bracket
            pattern = @"\)[^\)]*$";
            resetMethodSwitchable = Regex.Replace(resetMethodSwitchable, pattern, "");
            resetMethodSwitchable += " ,"+  enumName + " prop)";
            code.Append(@$"
            public {resetMethodSwitchable}
            {{
                switch(prop)
                {{"
            );
            
            foreach (var property in _properties)
            {
                var resetMethodCall = settings.GenerateResetMethodCall(property);
                code.Append(@$"
                    case {enumName}.{property}:
                        {resetMethodCall};
                        break;"
                );
            }
            
            code.Append(@"
                }
            }");

            if (settings.requireAsyncMethod)
            {
                changeMethodAsyncSwitchable = settings.GenerateChangeAsyncMethodName("ExposedProperty");
                // remove last bracket
                pattern = @"\)[^\)]*$";
                changeMethodAsyncSwitchable = Regex.Replace(changeMethodAsyncSwitchable, pattern, "");
                changeMethodAsyncSwitchable += " ,"+  enumName + " prop)";
                code.Append(@$"
            public async {changeMethodAsyncSwitchable}
            {{
                switch(prop)
                {{"
                );
            
                foreach (var property in _properties)
                {
                    var changeMethodCall = settings.GenerateChangeAsyncMethodCall(property);
                    code.Append(@$"
                    case {enumName}.{property}:
                        await {changeMethodCall};
                        break;"
                    );
                }
                code.Append(@"
                }
            }");
                
                
            }
            
            if (settings.requireAsyncMethod)
            {
                resetMethodAsyncSwitchable = settings.GenerateResetAsyncMethodName("ExposedProperty");
                // remove last bracket
                pattern = @"\)[^\)]*$";
                resetMethodAsyncSwitchable = Regex.Replace(resetMethodAsyncSwitchable, pattern, "");
                resetMethodAsyncSwitchable += " ,"+ enumName + " prop)";
                code.Append(@$"
            public async {resetMethodAsyncSwitchable}
            {{
                switch(prop)
                {{"
                );
            
                foreach (var property in _properties)
                {
                    var resetMethodCall = settings.GenerateResetAsyncMethodCall(property);
                    code.Append(@$"
                    case {enumName}.{property}:
                        await {resetMethodCall};
                        break;"
                    );
                }
                code.Append(@"
                }
            }");
                
                
            }

            foreach (var property in _properties)
            {

                var changeMethodSync = settings.GenerateChangeMethod(property);
                var resetMethodSync = settings.GenerateResetMethod(property);
                
                code.Append(changeMethodSync);
                code.Append(resetMethodSync);
                
                if (!settings.requireAsyncMethod) continue;
                var changeMethodAsync = settings.GenerateChangeAsyncMethod(property);
                var resetMethodAsync = settings.GenerateResetAsyncMethod(property);
                
                code.Append(changeMethodAsync);
                code.Append(resetMethodAsync);

            }

            code.Append(@"
        }");


            if (!settings.requireInterfaceGeneration)
            {
                code.Append(@$"
        public enum {enumName}
        {{
");
                foreach (var property in _properties)
                {
                    code.Append(@$"
            {property},");
                }
            
                code.Append(@"
        }");
            }


            if (!string.IsNullOrEmpty(settings.classNameSpace))
            {
                code.Append(@"
}");
            }



            return code.ToString();
        }

        private string GenerateInterfaceString(string interfaceName, string thisClassName)
        {
            // @""とすることで、複数行を書ける
            // ただ「"」は「""」として書きます
            StringBuilder code = new();

            code.Append(
                @$"
{settings.GenerateInterfaceImportNameSpace()}
");
    
                if(!string.IsNullOrEmpty(settings.interfaceNameSpace))
                {
                    code.Append(@$"
namespace {settings.interfaceNameSpace}
{{
");
                }
            
            code.Append(
                @$"
        /// <summary>
        /// This class is generated by script : {thisClassName}
        /// </summary>
        public interface {interfaceName}
        {{
"
            );
            
            code.Append(@"
                ");
            code.Append(changeMethodSwitchable);
            code.Append(@";
                ");
            code.Append(resetMethodSwitchable);
            code.Append(@";
                ");

            if (settings.requireAsyncMethod)
            {
                code.Append(@"
                ");
                code.Append(changeMethodAsyncSwitchable);
                code.Append(@";
                ");
                
                code.Append(resetMethodAsyncSwitchable);
                code.Append(@";
                ");
            }


            foreach (var property in _properties)
            {
                var changeMethodName = settings.GenerateChangeMethodName(property);
                var resetMethodName = settings.GenerateResetMethodName(property);

                code.Append(@"
                ");
                code.Append(changeMethodName);

                
                code.Append(@";
                ");
                code.Append(resetMethodName);
                code.Append(@";
");
                
                if (!settings.requireAsyncMethod) continue;
                var changeAsyncMethodName = settings.GenerateChangeAsyncMethodName(property);
                var resetAsyncMethodName = settings.GenerateResetAsyncMethodName(property);
                
                code.Append(@"
                ");
                code.Append(changeAsyncMethodName);
                code.Append(@";
                ");
                code.Append(resetAsyncMethodName);
                code.Append(@";
");

            }

            code.Append(@"
        }");
            
            if (!settings.requireInterfaceGeneration)
            {
                code.Append(@$"
        public enum {enumName}
        {{
");
                foreach (var property in _properties)
                {
                    code.Append(@$"
            {property},");
                }
            
                code.Append(@"
        }");
            }

            if (!string.IsNullOrEmpty(settings.interfaceNameSpace))
            {
                code.Append(@"
}");
            }

            return code.ToString();
        }
        
        

        
    }

}
